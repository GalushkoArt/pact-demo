---
title: Написание тестов потребителя (Consumer tests)
---

Искусство написания хороших consumer-тестов с Pact заключается в основном в понимании того, **что не стоит тестировать
**. Если всё сделать правильно, тесты будут лёгкими и полезными. Если нет — вы пожалеете, что не остались на
интеграционном тестировании. Тесты Pact должны быть **максимально гибкими**, но при этом гарантировать, что поставщик не
внесёт изменений, нарушающих совместимость.

Очень легко написать хрупкие, чрезмерно строгие, обременительные Pact-тесты, если не понимать, как именно их писать.
Стоит потратить время на осмысление, прежде чем начинать.

## Видео: как писать хорошие consumer-тесты

Следующее видео от мейнтейнера Pact, Бет Скёрри (Beth Skurrie), объясняет:

1. Каким должен быть хороший Pact-тест
2. Область охвата хорошего consumer-теста
3. Ответственности клиента API и почему не стоит включать бизнес-логику или UI
4. Варианты тестирования от "верхнего до нижнего" уровня
5. Эффективное использование matchers
6. Важные принципы (Закон Постела, лишние поля)
7. Функциональные тесты против контрактных
8. Как избежать хрупких или трудно поддерживаемых тестов
9. Сценарии на человеческом языке (BDD)
10. Цели хорошего контрактного теста

[Youtube link](https://www.youtube.com/watch?v=oPuHb9Rl8Zo)

## Используйте `Pact` для контрактного, а не функционального тестирования поставщика

* **Функциональное тестирование** проверяет корректность поведения поставщика — эти тесты должны быть в коде поставщика,
  и не являются задачей команды потребителя.
* **Контрактное тестирование** гарантирует, что потребитель и поставщик имеют общее понимание ожидаемых запросов и
  ответов.
* Pact-тесты должны фокусироваться на:
    * обнаружении **ошибок** в формировании запросов или обработке ответов
    * выявлении **недопонимания** в ожиданиях от ответов поставщика
* Pact-тесты **не должны** фокусироваться на:
    * поиске багов в логике поставщика (хотя это может быть побочным эффектом)

Подробнее о различиях между контрактным и функциональным тестированием
читайте [здесь](/consumer/contract_tests_not_functional_tests_ru).

**Правило:** *если вы не добавите этот сценарий, какую ошибку потребителя или недопонимание поведения поставщика вы
можете упустить? Если ответ — "никакую", не добавляйте этот тест.*

## Делайте утверждения только о том, что действительно важно для потребителя

Не проверяйте бизнес-правила поставщика (например, формат ID клиента `[A-Z]{3}-\d{3}`). Вместо этого утверждайте только
то, что повлияет на работу потребителя при изменении (например, ссылка должна начинаться с `http`, иначе ваше приложение
упадёт). Это позволяет поставщику эволюционировать, не нарушая работу потребителя.

## Выбирайте правильный тип сопоставления (matcher)

Для unit-тестов потребителя чаще всего подойдёт **точное совпадение**. Если вы покрываете Pact-ом больше, чем только
API-клиент, используйте более гибкое сопоставление (по типу, регулярки и т.д.).

В ответах **гибкое сопоставление** предпочтительнее. Но решение должно приниматься **для каждого поля отдельно**.

Задайте себе вопрос: *если я ослаблю/усилю это сопоставление — какие ошибки я пропущу/предотвращу?*

Если вы вынуждены использовать строгие сопоставления, потому что извлекаете данные из поля (например, ID из URL), это
сигнал, что API должен вернуть эти данные отдельно. Ваши тесты дают вам обратную связь!

## Используйте `Pact` для изолированных (unit) тестов

* как **mock** (вызовы проверяются), а не **stub** (вызовы не проверяются)
* только для классов/функций, отвечающих за HTTP-запросы между потребителем и поставщиком
* с осторожностью для функциональных/интеграционных тестов

**Почему?**

Если использовать Pact с точным сопоставлением для тестов, покрывающих UI, вы получите **хрупкие** тесты. Pact проверяет
каждый путь, параметр и заголовок, что приводит к экспоненциальному росту числа взаимодействий, необходимых для
верификации. Это увеличивает затраты на прохождение тестов у поставщика без реальной пользы.

## Не используйте Pact для UI-тестов

Если использовать Pact в UI-тестах, вы получите:

* сложные для отладки тесты (из-за множества взаимодействий)
* избыточные вызовы с незначительными вариациями данных, усложняющие поддержку

Вместо этого используйте shared fixtures или сгенерированный контракт для моков. Согласно пирамиде тестирования, большая
часть тестов UI должна быть изолированной.

## Осторожно используйте Pact в нефрагментированных тестах (интеграционных, функциональных)

* Оставьте изолированные тесты с точным сопоставлением — они проверяют корректную трансляцию доменных объектов в запросы
* В интеграционных тестах используйте **гибкое** сопоставление и выносите конфигурацию в общие методы

Если валидация взаимодействий не важна — используйте Webmock + shared fixtures.

## Все вызовы поставщика должны идти через протестированные классы/функции

Никогда не создавайте HTTP-запросы вручную в коде потребителя. Используйте клиентский класс/функцию, протестированный
Pact-ом — это даёт уверенность, что всё работает как ожидается.

## Осторожно с PUT/POST/PATCH — не допускайте GIGO

Каждое взаимодействие тестируется в изоляции. Вы не можете сделать PUT, а потом GET, чтобы проверить, записались ли
значения. Чтобы избежать GIGO (Garbage In, Garbage Out):

* Убедитесь, что ответ возвращает обновлённое состояние ресурса.
* Или используйте одну и ту же fixture и для PUT/POST тела, и для тела ответа GET.

## Используйте `can-i-deploy`

Воспользуйтесь [can-i-deploy](https://github.com/pact-foundation/pact_broker/wiki/Provider-verification-results)
из [Pact Broker CLI](https://github.com/pact-foundation/pact_broker-client#can-i-deploy), чтобы точно знать, можно ли
безопасно развернуть версию потребителя.

## В динамических языках проверяйте, что создаваемые модели соответствуют ответу

Проверьте, что ваши модели можно создать из тех ответов, которые вы ожидаете. Например: `last_login_time` — это `Time`
или `DateTime`? Используйте factory или fixtures. Подробнее —
в [этом gist](https://gist.github.com/bethesque/69ae590e8312523e5337).

## Руководство по лучшим практикам

Это руководство определяет лучшие практики для написания качественных unit-тестов потребителя с использованием Pact.
Каждое правило сопровождается примерами хорошей и плохой практики, чтобы вы могли проводить ревью или линтинг своих
тестов.

### 🧱 1. Структура и наименование тестов

#### ✅ Правило: Используйте осмысленные описания тестов

Они должны отражать **намерения клиента**, а не просто HTTP-метод.

**Обоснование:**
Осмысленные названия делают тесты понятнее и облегчают коммуникацию между командами потребителя и поставщика. Избегайте
повторений деталей, уже содержащихся в коде.

**✅ Хорошо:**

```ts
.uponReceiving("запрос на получение всех продуктов")
````

**❌ Плохо:**

```ts
.uponReceiving("GET /products") // Дублирует URL, уже указанный в тесте
```

#### ✅ Правило: Используйте читаемые сценарии (в стиле BDD)

Комбинируйте состояние, описание запроса и ожидаемый ответ в "естественный язык".

**Обоснование:**
Это облегчает понимание целей теста даже для людей вне разработки, особенно в UI Pact Broker.

**✅ Хорошо:**

```ts
.addInteraction()
    .given("в каталоге есть активные продукты")
    .uponReceiving("запрос на получение всех продуктов")
    .withRequest("GET", "/products")
    .willRespondWith(200, ...)
```

Читается как:

> **Дано**, что в каталоге есть активные продукты, **при получении** запроса на их получение, **поставщик вернёт** HTTP
> 200 со списком продуктов.

**❌ Плохо:**

```ts
.addInteraction()
    .uponReceiving("GET /products")
    .withRequest("GET", "/products")
    .willRespondWith(200, ...)
```

#### ✅ Правило: Используйте единый шаблон для всех тестов

**Обоснование:**
Единый подход упрощает чтение, ревью и поддержку, особенно в больших командах.

**✅ Хорошо:**

```ts
describe("API «Thing»", () => {
    const pact = new PactV4({
        consumer: "ThingConsumer",
        provider: "ThingProvider",
        spec: SpecificationVersion.SPECIFICATION_VERSION_V4,
    });

    describe("GET /thing/:id", () => {
        test("если вещь найдена — возвращает 200", async () => {
            await pact
                .addInteraction()
                .given("вещь с id 1 существует")
                .uponReceiving("запрос на получение вещи с ID 1")
                .withRequest("GET", "/thing/1", (builder) => {
                    builder.headers({Accept: "application/json"});
                })
                .willRespondWith(200, (builder) => {
                    builder.jsonBody(like({id: 1, name: "Thing 1", price: 100}));
                })
                .executeTest(async (mockserver) => {
                    const ThingAPI = new ThingAPI(mockserver.url);
                    const thing = await ThingAPI.getThingById(1);
                    expect(thing).toEqual({id: 1, name: "Some 1", price: 100});
                });
        });
    });
});
```

**❌ Плохо:**

```ts
describe("Pact Tests", () => {
    const pact = new PactV4({...});

    test("вызов API", async () => {
        await pact
            .addInteraction()
            .uponReceiving("получить вещь")
            .withRequest("GET", "/thing/1", (builder) => {
                builder.headers({Accept: "application/json"});
            })
    ...
    });
});
```

### 🧪 2. Дизайн и охват тестов

#### ✅ Правило: Тест должен «ловить баг»

**Обоснование:**
Каждый пример в контракте должен быть нужен. Если удалить тест, и от этого не появится риск сломать потребителя
незаметно — значит, он был лишним.

✅ Пример:
Если поведение потребителя зависит от поля `status`, нужно тестировать каждый вариант:

```ts
export function handleDecision(response: { status: string }) {
    switch (response.status) {
        case 'approved':
            return '✅ Разрешено';
        case 'rejected':
            return '❌ Отклонено';
        case 'pending':
            return '⏳ Ожидание';
        default:
            throw new Error(`Необработанный статус: ${response.status}`);
    }
}
```

Каждый ответ — отдельный `it(...)` с соответствующим статусом.

❌ Плохо:
Тестируем только `'approved'`, не охватывая другие ветки логики.

#### ✅ Правило: Тестируйте настоящий API-клиент

**Обоснование:**
Тест должен вызывать **реальный код потребителя**, а не прямой `fetch` или `axios`.

✅ Хорошо:

```ts
const result = await getUser(client, '123');
expect(result).toEqual({id: '123', name: 'Alice'});
```

❌ Плохо:

```ts
const response = await axios.get(...); // Бypaвнe consumer logic
```

#### ✅ Правило: Один тест — одно взаимодействие

**Обоснование:**
Это делает ошибки понятными и упрощает проверку взаимодействий.

✅ Хорошо:

```ts
test("200, если продукт найден", ...);
test("404, если продукт не найден", ...);
```

❌ Плохо:

```ts
test("все продуктовые эндпоинты", async () => {
    // Слишком много всего
});
```

#### ✅ Правило: Минимум утверждений — только про контракт

**Обоснование:**
Не добавляйте проверки логов, побочных эффектов и прочего — они увеличивают шум.

✅ Хорошо:

```ts
expect(response).toEqual([...]);
```

❌ Плохо:

```ts
expect(response).toEqual([...]);
expect(logger.debug).toHaveBeenCalled();
```

#### ✅ Правило: В контракте только то, что реально используется

**Обоснование:**
Чем больше вы включаете, тем выше вероятность ложных срабатываний при изменениях поставщика.

✅ Хорошо:

```ts
jsonBody({id: like("123"), name: like("Product 1"), price: like(37.25)});
```

❌ Плохо:

```ts
jsonBody({id: ..., name: ..., price: ..., availableStores: [...], ...});
```

#### ✅ Правило: Контракт ≠ функциональный тест

**Обоснование:**
Контракт проверяет структуру HTTP, а не бизнес-логику.

✅ Хорошо:

```ts
test("возвращает продукты в корректном формате", ...);
```

❌ Плохо:

```ts
test("считает итоговую сумму корзины", ...); // Это уже бизнес-логика
```

### 🧭 3. Ясность и поддерживаемость

#### ✅ Правило: Используйте provider states

**Обоснование:**
Это делает тесты понятными и воспроизводимыми при верификации.

✅ Хорошо:

```ts
.
given("продукт с ID 1 существует")
    .uponReceiving("запрос на этот продукт")
```

❌ Плохо:

```ts
.
uponReceiving("запрос на продукт") // Нет контекста
```

#### ✅ Правило: Используйте matchers

**Обоснование:**
Match’и (`like`, `eachLike`) делают тесты гибкими и устойчивыми.

✅ Хорошо:

```ts
eachLike({id: like("123"), name: like("Product 1")})
```

❌ Плохо:

```ts
[{id: "123", name: "Product 1"}] // Хрупко
```

#### 🧱 Не переусложняйте контракт

**Обоснование:**
Не используйте regex, если потребитель не зависит от этого.

✅ OK:

```json
{
  "customerId": "ABC-123"
}
```

❌ Переусложнение:

```ts
{
    "customerId"
:
    regex("[A-Z]{3}-\\d{3}", "ABC-123")
}
```

#### ✅ Правило: Уникальные описания взаимодействий

**Обоснование:**
Broker считает interaction по `description + providerState`, повторения — ведут к удалению дубликатов.

✅ Хорошо:

```ts
.
given("есть продукты").uponReceiving("запрос на продукт")
    .given("нет продуктов").uponReceiving("запрос на продукт") // OK: providerState другой
```

❌ Плохо:

```ts
.
uponReceiving("запрос на продукт")
... // Повтор — одна перезапишет другую
```

#### ✅ Правило: Делайте Pact-файлы детерминированными

**Обоснование:**
Динамические данные (uuid, timestamp) = нестабильные тесты, лишние diffs в Git.

✅ Хорошо:

```ts
jsonBody({
    id: like("123"),
    createdAt: dateTime("yyyy-MM-dd'T'HH:mm:ss.SSSXXX", "2024-01-01T00:00:00.000Z")
});
```

❌ Плохо:

```ts
jsonBody({
    id: uuid(), // каждый раз новый
    createdAt: dateTime("yyyy-MM-dd'T'HH:mm:ss.SSSXXX") // нет значения по умолчанию
});
```

> ℹ️ Совет: всегда указывайте пример при использовании генераторов (`uuid()`, `timestamp()` и т.д.)

### 🔒 4. Безопасность

#### ✅ Правило: Не включайте чувствительные данные

**Обоснование:**
Pact-файлы могут попасть в общий репозиторий или broker. Никаких токенов и паролей!

✅ Хорошо:

```ts
builder.headers({
    Authorization: like("Bearer <token>")
});
```

❌ Плохо:

```ts
builder.headers({
    Authorization: "Bearer real-production-token"
});
```
