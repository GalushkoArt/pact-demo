---
title: Когда использовать Pact
---

> Когда в твоих руках только молоток, всё вокруг кажется гвоздями...

Как и любой инструмент, Pact хорошо подходит для одних случаев и не очень — для других. В правильной ситуации Pact
поможет сделать тестирование интеграций _менее болезненным_, чем традиционные интеграционные тесты. В неправильной —
будет так же тяжело, как и всегда!

## В чём Pact особенно хорош?

Pact особенно полезен при разработке и тестировании интеграций, если выполняются следующие условия:

* Вы (или ваша команда/организация/партнёрская организация) контролируете разработку и потребителя, и поставщика.
* И потребитель, и поставщик находятся в активной разработке.
* Команда поставщика может легко управлять данными, возвращаемыми в ответах.
* Требования потребителя(ей) определяют фичи, реализуемые в поставщике.
* Количество потребителей у поставщика достаточно мало, чтобы можно было поддерживать индивидуальные отношения с каждой
  потребительской командой.

Основные преимущества:

* Вы можете непрерывно развивать код, зная, что Pact гарантирует соответствие контрактов.
* Вы узнаёте _до_ деплоя, смогут ли ваши приложения работать вместе — нет необходимости ждать медленных end-to-end
  тестов.

Pact — отличный инструмент для разработки и тестирования микросервисов внутри одной организации.

## В чём Pact неэффективен?

* Тестирование API, если другая сторона интеграции не использует Pact.
* Тестирование API, где потребителей нельзя идентифицировать по отдельности (например, публичные API).
* Сценарии, где невозможно загрузить данные в поставщика без использования самого тестируемого API (например, публичные
  API). [Почему?](#почему-pact-может-быть-неподходящим-инструментом-для-тестирования-публичных-api)
* Сценарии, где вы не можете контролировать данные, используемые в ответах поставщика.
* Тестирование новых или существующих поставщиков, если их функциональность не зависит от конкретных потребителей (
  например, полностью стабильный публичный API или OAuth-поставщик).
* Тестирование поставщиков, если у команд потребителя и поставщика нет эффективной коммуникации.
* Тестирование производительности и нагрузки.
* [Функциональное тестирование](../consumer/contract_tests_not_functional_tests_ru) поставщика — это должны делать его
  собственные тесты. Pact проверяет только содержимое и формат запросов и ответов.
* Тестирование "прокси"-API, где поставщик просто пересылает запрос дальше, не проверяя его
  содержимое. [Почему?](#Почему-Pact-может-быть-неподходящим-инструментом-для-тестирования-прокси-API-таких-как-BFF)
* Использование как общего инструмента моков или стабов в браузерных
  UI-тестах. [Почему?](/consumer#avoid-using-pact-for-tests-that-involve-the-ui)

### Почему Pact может быть неподходящим инструментом для тестирования публичных API

Если вы используете Pact для тестирования публичного API, то единственный способ установить нужное состояние
поставщика — использовать сам тестируемый API. Это делает тесты более медленными и хрупкими по сравнению с обычными
верификациями Pact. Сброс состояния между взаимодействиями может быть очень медленным, особенно если нужно очистить
множество сущностей. Возможной альтернативой может быть модификация запросов так, чтобы они работали в новом контексте
каждый раз.

Если это всё же лучше, чем интеграционные тесты или другие инструменты — пробуйте. Но настоятельно не рекомендуем
полагаться на состояние, установленное предыдущими взаимодействиями — это ведёт к нестабильным тестам с трудными для
понимания зависимостями. Последовательность взаимодействий внутри контракта или при воспроизведении не гарантируется во
всех реализациях Pact.

### Почему Pact может быть неподходящим инструментом для тестирования прокси-API, таких как BFF

Во время верификации Pact не проверяет побочные эффекты выполнения запроса у поставщика — он лишь сравнивает тело ответа
с ожидаемым. Если ваш API просто пересылает сообщение вниз по цепочке (например, в очередь) и не проверяет содержимое
тела, вы можете отправить в теле всё, что угодно — и всё равно получить один и тот же ответ. Настоящий "контракт",
который вы хотите проверить, — между потребителем и нижестоящей системой. Ответ `200 OK` от поставщика не даёт
уверенности, что потребитель и конечная система действительно будут работать вместе.

Вам нужен "не-HTTP" контракт между потребителем и системой внизу. Посмотрите
этот [gist](https://gist.github.com/bethesque/0ee446a9f93db4dd0697) с примером использования Pact для тестирования
не-HTTP взаимодействий.

## Если вы не уверены

Если вы не уверены, будет ли Pact полезен вашей команде — прочитайте [эту страницу](../faq/convinceme_ru.md).
