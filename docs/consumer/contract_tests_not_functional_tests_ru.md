---
title: Контрактные тесты против функциональных тестов
---

Контрактные тесты сосредоточены на сообщениях, которыми обмениваются потребитель и поставщик, тогда как функциональные
тесты также проверяют, произошли ли ожидаемые побочные эффекты. Например, представим конечную точку `/orders`,
принимающую `POST`-запрос для создания нового заказа. Контрактный тест проверяет, что потребитель и поставщик имеют
общее и точное понимание запроса и ответа, необходимых для создания заказа. Функциональный тест для поставщика, в свою
очередь, проверит, что при отправке такого запроса объект `Order` с корректными атрибутами действительно сохраняется в
базе данных. **Контрактный тест _не проверяет побочные эффекты_**.

Более тонкое различие требуется в случае взаимодействий без побочных эффектов, например, ответов с ошибками валидации.

Представим простой _User Service_, позволяющий потребителям регистрировать новых пользователей — как правило, через
POST-запрос с данными пользователя в теле запроса.

Сценарий «счастливого пути» может выглядеть так:

```text
Допустим, "не существует пользователя с именем Mary"
Когда "создаётся пользователь с именем Mary"
  POST /users { "username": "mary", email: "...", ... }
Тогда
  Ожидается ответ 200 OK
````

Ограничение только сценариями успешного выполнения опасно — можно упустить разные коды ответов и неверно понять
поведение поставщика. Посмотрим на сценарий с ошибкой:

```text
Допустим, "уже существует пользователь с именем Mary"
Когда "создаётся пользователь с именем Mary"
  POST /users { "username": "mary", email: "...", ... }
Тогда
  Ожидается ответ 409 Conflict
```

Всё отлично — покрываем новое поведение и новый код ответа.

Теперь мы пообщались с командой, поддерживающей *User Service*, и они рассказали, что `username` может быть максимум 20
символов, содержать только буквы, и не может быть пустым. Может быть, стоит добавить это в контракт?

Вот тут начинается скользкий путь. Возникает соблазн добавить три сценария в контракт:

```text
Когда "создаётся пользователь с пустым username"
  POST /users { "username": "", email: "...", ... }
Тогда
  Ожидается ответ 400 Bad Request
  Ожидается тело ответа: { "error": "username cannot be blank" }
```

```text
Когда "создаётся пользователь с username длиной 21 символ"
  POST /users { "username": "thisisalooongusername", email: "...", ... }
Тогда
  Ожидается ответ 400 Bad Request
  Ожидается тело ответа: { "error": "username cannot be more than 20 characters" }
```

```text
Когда "создаётся пользователь с username, содержащим цифры"
  POST /users { "username": "us3rn4me", email: "...", ... }
Тогда
  Ожидается ответ 400 Bad Request
  Ожидается тело ответа: { "error": "username can only contain letters" }
```

В этот момент мы выходим за рамки контрактных тестов и проверяем, что *User Service* корректно реализует правила
валидации — это уже функциональное тестирование, которое должно выполняться внутри самого *User Service*.

Какая в этом проблема? Больше тестов — это хорошо, верно? Проблема в том, что такие тесты создают **чрезмерно жёсткий
контракт**. Что если команда *User Service* решит, что 20 символов недостаточно, и увеличит лимит до 50? А если теперь
разрешены цифры в имени пользователя? Потребители не должны пострадать от этих изменений, но при такой контрактной
спецификации даже **ослабление валидации** приведёт к нарушению контракта. Это не ломающие изменения, но мы фактически
запрещаем их внедрение.

Вместо этого, вернёмся к сценариям и оставим только один обобщённый пример реакции на невалидный ввод:

```text
Когда "создаётся пользователь с недопустимым username"
  POST /users { "username": "bad_username_that_breaks_some_rule_that_you_are_fairly_confident_will_not_change", ... }
Тогда
  Ответ: 400 Bad Request
  Тело ответа: { "error": "<любая строка>" }
```

Нюанс тонкий, но подход гораздо более гибкий! Теперь команда *User Service* может изменять большинство правил валидации,
не нарушая Pact. Нас не волнуют конкретные бизнес-правила — нас интересует лишь то, что в случае некорректного ввода мы
понимаем, как *User Service* отреагирует.

Когда пишете тест взаимодействия, задайте себе вопрос — **что вы пытаетесь проверить?** Контракты должны помогать
выявлять:

* ошибки в коде потребителя
* неправильное понимание API потребителем
* ломающие изменения от поставщика

Иными словами, ваши сценарии Pact **не должны лезть в бизнес-логику поставщика**, а лишь проверять, что потребитель и
поставщик понимают друг друга по части запросов и ответов. В случае с валидацией описывайте **то, *как* происходит отказ
**, а не **почему**.

## Кто за что отвечает?

| Утверждение                                            | Тест                                               |
|:-------------------------------------------------------|:---------------------------------------------------|
| Действительно ли потребитель делает ожидаемый запрос?  | Контрактный тест потребителя (Pact mock service)   |
| Обрабатывает ли потребитель ожидаемый ответ?           | Контрактный тест потребителя (собственные ассерты) |
| Обрабатывает ли поставщик ожидаемый запрос?            | Верификация поставщика (Pact verifier CLI)         |
| Возвращает ли поставщик ожидаемый ответ?               | Верификация поставщика (Pact verifier CLI)         |
| Выполняет ли поставщик правильные действия с запросом? | Функциональные тесты самого поставщика             |

### Проверка: потребитель делает ожидаемый запрос?

Настройки на mock-сервере Pact позволяют проверить, что код потребителя формирует корректный HTTP-запрос к поставщику.
Например, правильный `Content-Type`, заголовок `Accept`, сериализация тела. Mock-сервер вызовет ошибку, если запрос не
совпадает с ожидаемым.

### Проверка: потребитель обрабатывает ожидаемый ответ?

Обрабатывает ли код потребителя все ожидаемые коды ответа? Например:

* корректно парсит JSON в объект домена при 200
* возвращает `nil` при 404
* создаёт объект ошибки при 400
* выбрасывает исключение при 500

Эти проверки выполняются вашим собственным тестовым фреймворком.

### Проверка: поставщик обрабатывает ожидаемый запрос?

Являются ли путь, query-параметры, тело и заголовки правильным способом вызова API поставщика? Задача Pact verifier
воспроизводит каждый запрос из контракта и проверяет, как настоящий сервер поставщика среагирует.

### Проверка: поставщик возвращает ожидаемый ответ?

Возвращает ли поставщик статус, тело и заголовки, которые ожидает потребитель? Pact verifier сравнивает фактический
ответ с ожидаемым, указанным в контракте.

### Проверка: поставщик выполняет правильные действия?

Обрабатывает ли поставщик полученные данные корректно? Какие побочные эффекты происходят? Например:

* сохраняется ли новый ресурс в хранилище?
* публикуется ли сообщение в очередь?
* изменяется ли состояние связанного ресурса?
