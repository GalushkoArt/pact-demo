# Демонстрация контрактного тестирования с Pact

Этот проект демонстрирует контрактное тестирование на основе Pact в микросервисной архитектуре, фокусируясь на домене сервиса цен с REST API коммуникацией между сервисами поставщика и потребителя.

После прочтения README можно посмотреть [статью по внедрению контрактного тестирования](Внедрение%20контрактного%20тестирования%20с%20Pact%20в%20приложениях%20Java%20Spring.md)

## Обзор проекта

В современных микросервисных архитектурах обеспечение надежной коммуникации между сервисами имеет решающее значение. Этот демонстрационный проект показывает, как реализовать контрактное тестирование с использованием Pact, инструмента контрактного тестирования, управляемого потребителем, который помогает командам обнаруживать проблемы интеграции на ранних этапах цикла разработки.

### Ключевые особенности

- **Контракты, управляемые потребителем**: Потребители определяют свои ожидания, поставщики проверяют, что они могут их удовлетворить
- **Автоматизированная проверка контрактов**: Интеграция CI/CD гарантирует, что контракты всегда проверяются
- **Общий Pact Broker**: Центральный репозиторий для контрактов с видимостью совместимости
- **Интеграция с Spring Boot**: Бесшовная интеграция с приложениями Spring Boot
- **Тестирование аутентификации**: Проверка защищенных конечных точек с правильной аутентификацией
- **Динамическое управление состоянием**: Гибкая настройка состояния поставщика для надежного тестирования

Проект использует генерацию кода на основе спецификации Open API, демонстрируя, как контрактное тестирование может дополнять подходы к разработке API-first.

## Предварительные требования

- Java 17 или выше
- Gradle 8.0 или выше
- Docker и Docker Compose (для запуска Pact Broker и PostgreSQL)

## Начало работы

### 1. Клонируем репозиторий

```bash
git clone https://github.com/GalushkoArt/pact-demo.git
cd pact-demo
```

### 2. Запускаем PostgreSQL и Pact Broker

```bash
# Используя Makefile
make docker-start

# Или напрямую с docker-compose
docker-compose up -d
```

Это запустит:
- PostgreSQL для приложения на порту 5432
- PostgreSQL для тестов на порту 5433
- Pact Broker на порту 9292

Pact Broker будет доступен по адресу http://localhost:9292 со следующими учетными данными:
- Имя пользователя: `pact`
- Пароль: `pact`

### 3. Структура проекта

Перед запуском тестов ознакомьтесь со структурой проекта:

- **price-service-provider**: Сервис, реализующий API (поставщик)
- **price-service-consumer**: Клиент, потребляющий API (потребитель)
- **new-price-service-consumer**: Еще один клиент, потребляющий API (потребитель)

Каждый модуль содержит:
- `src/main/java`: Код приложения
- `src/test/java`: Тестовый код, включая контрактные тесты Pact
- `build.gradle`: Зависимости и конфигурация Pact для конкретного модуля

### 4. Запуск полной демонстрации

Вы можете запустить полную демонстрацию рабочего процесса:

```bash
# Запуск полной демонстрации
make full-workflow
```

Но советую пройтись по шагам инструкции в разделе "Демонстрация рабочего процесса контрактного тестирования".

### 5. Реализация собственных контрактных тестов

Для реализации собственных контрактных тестов:

1. **Для потребителей(клиентов)**:
   - См. примеры в `price-service-consumer/src/test/java/com/example/priceclient/client/PriceApiPactTest.java`
   - Определите ожидания с помощью DSL Pact
   - Запустите тесты для генерации файлов контрактов
   - Опубликуйте контракты в Pact Broker

2. **Для поставщиков(серверов)**:
   - См. примеры в `price-service-provider/src/test/java/com/example/priceservice/pact/PriceServiceProviderPricePactTest.java`
   - Реализуйте состояния поставщика
   - Проверьте на соответствие контрактам из Pact Broker

## Детали модулей

### Генерация кода с Open API

Все модули в этом проекте используют генерацию кода на основе спецификации Open API:

- Спецификация определена в файле `oas/openapi.yaml`
- Поставщик использует ее для генерации интерфейсов контроллеров
- Потребители используют ее для генерации клиентского кода

Этот подход гарантирует, что все сервисы работают с одним и тем же API-контрактом.

### price-service-provider

Поставщик реализует REST API для сервиса цен со следующими конечными точками:

- `GET /prices`: Получить все цены
- `GET /prices/{instrumentId}`: Получить цену для конкретного инструмента
- `POST /prices/{instrumentId}`: Создать или обновить цену для конкретного инструмента (требует аутентификации)
- `DELETE /prices/{instrumentId}`: Удалить цену для конкретного инструмента (требует аутентификации)
- `GET /orderbook/{instrumentId}`: Получить книгу заказов для конкретного инструмента
- `POST /orderbook/{instrumentId}`: Создать или обновить книгу заказов для конкретного инструмента (требует аутентификации)

#### Аутентификация

Поставщик использует базовую аутентификацию для операций POST и DELETE:
- Имя пользователя: `admin`
- Пароль: `password`

Пример использования curl:
```bash
curl -X POST -u admin:password -H "Content-Type: application/json" -d '{"instrumentId":"GOOG","bidPrice":2750.00,"askPrice":2752.50,"lastUpdated":"2023-05-29T10:00:00.000"}' http://localhost:8080/prices/GOOG
```

#### Конфигурация базы данных

Поставщик использует PostgreSQL для хранения данных. Конфигурацию базы данных можно изменить в `application.properties`:

```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/priceservice
spring.datasource.username=postgres
spring.datasource.password=postgres
```

Миграции Flyway используются для создания схемы базы данных и вставки примеров данных.

### price-service-consumer

Потребитель реализует клиент для сервиса цен с:

- REST-клиентом для связи с поставщиком
- Поддержкой аутентификации для защищенных конечных точек
- Контрактными тестами Pact, определяющими ожидаемое поведение
- Сервисным слоем для бизнес-логики

Тесты потребителя можно запустить с помощью:

```bash
make consumer-tests
```

Это сгенерирует контракты Pact в [price-service-consumer/build/pacts/](price-service-consumer/build/pacts/) и опубликует их в Pact Broker.

#### Конфигурация потребителя

Конфигурацию потребителя можно изменить в `application.properties`:

```properties
price-service.base-url=http://localhost:8080
price-service.username=admin
price-service.password=password
```

### new-price-service-consumer

Это еще одна реализация потребителя, которая также взаимодействует с сервисом цен:

- Использует ту же спецификацию Open API для генерации клиента
- Реализует собственный набор контрактных тестов Pact
- Демонстрирует, как несколько потребителей могут взаимодействовать с одним и тем же поставщиком
- Показывает, как Pact может управлять совместимостью между несколькими потребителями и поставщиком

Тесты нового потребителя можно запустить с помощью:

```bash
make new-consumer-tests
```

Это сгенерирует контракты Pact в [new-price-service-consumer/build/pacts/](new-price-service-consumer/build/pacts/) и опубликует их в Pact Broker.

### pact-broker

Настройка Docker Compose для Pact Broker, включая:

- Сервис Pact Broker
- База данных PostgreSQL для хранения контрактов

## Демонстрация рабочего процесса контрактного тестирования

Этот раздел демонстрирует полный рабочий процесс с использованием команд из Makefile. Следуйте этим шагам, чтобы понять, как работает контрактное тестирование с Pact на практике.

### 1. Запустить контейнеры

Сначала запустите контейнеры Docker для PostgreSQL и Pact Broker:

```bash
make docker-start
```

Эта команда запускает контейнеры в отсоединенном режиме и ждет, пока они будут готовы.

### 2. Запустить тесты потребителя и создать контракты

Запустите тесты для первого потребителя и опубликуйте сгенерированные контракты Pact в брокере:

```bash
make consumer-tests
```

Это:
- Запустит тесты для price-service-consumer
- Сгенерирует файлы контрактов Pact (расположенные в [price-service-consumer/build/pacts/](price-service-consumer/build/pacts/))
- Опубликует контракты в Pact Broker

### 3. Проверить Pact Broker

Откройте пользовательский интерфейс Pact Broker, чтобы увидеть опубликованные контракты:
[http://localhost:9292/](http://localhost:9292/)

Вы должны увидеть контракты между price-service-consumer и price-service-provider.

### 4. Проверить поставщика на соответствие контрактам

Запустите тесты проверки поставщика, чтобы убедиться, что поставщик может выполнить контракты:

```bash
make pact-tests
```

Эта команда запускает тесты JUnit5 в модуле price-service-provider, который проверяет поставщика на соответствие опубликованным контрактам Pact.

### 5. Проверить Pact Broker снова

Обновите пользовательский интерфейс Pact Broker, чтобы увидеть результаты проверки:
[http://localhost:9292/](http://localhost:9292/)

Теперь вы должны увидеть, что контракты были проверены.

### 6. Проверить совместимость деплоя

Проверьте, можно ли безопасно развернуть потребителя и поставщика:

```bash
make canideploy-price
make canideploy-orderbook
make canideploy-consumer
```

Эта команда проверяет, могут ли price-service-provider-price, price-service-provider-orderbook и price-service-consumer быть задеплоены без нарушения работы какого-либо договора.
Теперь должно быть сказано `Computer says yes \o/`.

### 7. Запустить тесты для нового потребителя

Запустите тесты для нового потребителя и опубликуйте его контракты:

```bash
make new-consumer-tests
```

Это:
- Запустит тесты для new-price-service-consumer
- Сгенерирует файлы контрактов Pact (расположенные в [new-price-service-consumer/build/pacts/](new-price-service-consumer/build/pacts/))
- Опубликует контракты в Pact Broker

### 8. Проверить совместимость развертывания Orderbook

Проверьте, можно ли безопасно развернуть поставщика orderbook:

```bash
make canideploy-orderbook
```

Это должно пройти с `Computer says yes \o/`, потому что новый потребитель не использует этого поставщика.

### 9. Проверить совместимость развертывания Price

Проверьте, можно ли безопасно развернуть поставщика price:

```bash
make canideploy-price
```

Это должно завершиться неудачей с `Can you deploy? Computer says no ¯\_(ツ)_/¯`, потому что новый потребитель использует этого поставщика, а поставщик еще не проверил новые контракты.

### 10. Запустить тесты поставщика снова

Запустите тесты поставщика снова:

```bash
make pact-tests
```

Это проверит все контракты, включая контракты от нового потребителя.

### 11. Проверить Pact Broker еще раз

Обновите пользовательский интерфейс Pact Broker еще раз, чтобы увидеть обновленные результаты проверки:
[http://localhost:9292/](http://localhost:9292/)

Теперь вы должны увидеть, что все контракты были проверены.

### 12. Проверить совместимость развертывания снова

Проверьте, можно ли теперь безопасно развернуть обоих поставщиков:

```bash
make canideploy-price
make canideploy-orderbook
make canideploy-new-consumer
```

Теперь это должно пройти с `Computer says yes \o/` для обоих поставщиков и нового потребителя.

## Динамическое управление состоянием

Поставщик использует динамическое управление состоянием для проверки контрактов:

- Каждое состояние поставщика реализовано как метод, аннотированный с `@State`
- Методы состояния настраивают необходимые данные для каждого взаимодействия
- Это обеспечивает изоляцию и повторяемость тестов
- Нет зависимости от предварительно выделенных данных

Пример:
```java
@State("price with ID exists")
@Transactional
public void priceWithIdAaplExists() {
    // Очистить существующие данные для этого ID
    priceJpaRepository.findById("AAPL").ifPresent(price -> priceJpaRepository.delete(price));

    // Создать тестовые данные
    PriceEntity apple = PriceEntity.builder()
            .instrumentId("AAPL")
            .bidPrice(new BigDecimal("175.50"))
            .askPrice(new BigDecimal("175.75"))
            .lastUpdated(LocalDateTime.now())
            .build();

    priceJpaRepository.save(apple);
}
```

## Тестирование аутентификации

Проект включает тестирование аутентификации:

- Тесты для успешной аутентификации
- Тесты для неудачной аутентификации (это должно охватывать случаи, когда учетные данные отсутствуют или неверны)

Это гарантирует, что требования безопасности правильно проверяются через контракты.

## Лучшие практики для контрактного тестирования с Pact

### Лучшие практики на стороне потребителя

1. **Используйте сопоставители типов вместо точных значений**
   ```java
   // ХОРОШО: Использование сопоставителей типов делает контракт более гибким
   .body(newJsonBody(body -> {
       body.decimalType("bidPrice", 175.50);
       body.decimalType("askPrice", 175.75);
   }).build())
   ```

2. **Определяйте четкие состояния поставщика**
   ```java
   // ХОРОШО: Состояние поставщика четко определено
   .given("price with ID exists")
   .uponReceiving("a request for price with ID AAPL")
   ```

3. **Тестируйте сценарии ошибок**
   - Включайте тесты для 404 Not Found, 401 Unauthorized и т.д.
   - Проверяйте правильную обработку ошибок в вашем клиентском коде

4. **Правильно обрабатывайте аутентификацию**
   - Включайте заголовки аутентификации в ваши контрактные тесты
   - Тестируйте как успешные, так и неудачные сценарии аутентификации

5. **Используйте гибкие утверждения**
   ```java
   // ХОРОШО: Утверждение наличия значений, а не их точного содержания
   assertThat(price.getBidPrice()).isNotNull();
   ```

### Лучшие практики на стороне поставщика

1. **Мокируйте на уровне репозитория**
   - Избегайте мокирования контроллеров или сервисов
   - Используйте моки репозиториев или базы данных в памяти для более реалистичных тестов

2. **Очищайте тестовые данные**
   ```java
   @State(value = "price with ID exists", action = StateChangeAction.TEARDOWN)
   public void priceWithIdExistsCleanup() {
       // Код очистки здесь
   }
   ```

3. **Используйте селекторы версий**
   ```java
   @PactBrokerConsumerVersionSelectors
   public static SelectorBuilder consumerVersionSelectors() {
       return new SelectorBuilder()
               .mainBranch()
               .tag("prod")
               .latestTag("dev");
   }
   ```

4. **Обрабатывайте аутентификацию в тестах поставщика**
   - Заменяйте заголовки аутентификации в запросах
   - Обеспечивайте правильный контекст безопасности для тестов

5. **Используйте динамическое управление состоянием**
   - Создавайте тестовые данные динамически для каждого теста
   - Избегайте зависимости от предварительно существующих данных
6. **Генерируйте безопасные идентификаторы тестовых данных**
   - Используйте `TestDataFactory.randomInstrumentId()` для уникальных ID
   - Для детерминированного режима задайте `-Dtest.deterministic=true`

## Распространенные проблемы и решения

### 1. Тесты проходят локально, но не проходят в CI

**Проблема**: Контрактные тесты проходят на вашей локальной машине, но не проходят в конвейере CI.

**Решение**:
- Убедитесь, что переменные окружения правильно установлены в CI
- Проверьте, что URL и учетные данные Pact Broker верны
- Убедитесь, что состояния поставщика точно совпадают между тестами потребителя и поставщика

### 2. Проблемы с аутентификацией

**Проблема**: Тесты не проходят с ошибками 401 Unauthorized.

**Решение**:
- Убедитесь, что заголовки аутентификации правильно установлены в тестах потребителя
- Реализуйте правильную обработку аутентификации в тестах поставщика:
  ```java
  private void replaceAuthHeader(HttpRequest request) {
      if (request.containsHeader("Authorization")) {
          request.removeHeaders("Authorization");
          request.addHeader("Authorization", AUTH_HEADER);
      }
  }
  ```

### 3. Состояния поставщика не работают

**Проблема**: Тесты поставщика не проходят, потому что ожидаемое состояние не настроено правильно.

**Решение**:
- Убедитесь, что имена состояний поставщика точно совпадают между потребителем и поставщиком
- Используйте динамические параметры состояния при необходимости:
  ```java
  @State(value = "price with ID exists")
  public Map<String, String> priceWithIdExists() {
      var parameters = new HashMap<String, String>();
      var instrumentId = parameters.computeIfAbsent("instrumentId",
          id -> TestDataFactory.randomInstrumentId());
      // Код настройки с использованием instrumentId
      return parameters;
  }
  ```

### 4. Ошибки проверки контракта

**Проблема**: Проверка поставщика не проходит с неожиданным ответом или кодом состояния.

**Решение**:
- Сравните фактический ответ с ожидаемым ответом в контракте
- Проверьте наличие изменений в API поставщика, которые могут нарушить контракт
- Обновите тесты потребителя, если API изменился намеренно

### Антипаттерны

1. **Слишком точные контракты** – избегайте совпадения по точным значениям, если это не нужно. Используйте сопоставители типов.
2. **Общий доступ к базе данных между тестами** – каждое состояние должно создавать и очищать свои данные.
3. **Отсутствие сценариев ошибок** – обязательно включайте негативные кейсы, такие как 404 или ошибки аутентификации.

Такие практики приводят к нестабильным тестам и ненадежным контрактам.

## Когда использовать Pact по сравнению с другими видами тестирования

- **Модульные тесты**: Для тестирования бизнес-логики в изоляции
- **Компонентные тесты**: Для тестирования бизнес-логики сервиса с моками и базой данных, работающей в docker
- **Тесты Pact**: Для тестирования границ сервисов и API-контрактов
- **Интеграционные тесты**: Для тестирования взаимодействий с базами данных и другими зависимостями
- **Сквозные тесты**: Для тестирования критических пользовательских сценариев

Pact особенно ценен, когда:
- У вас есть несколько сервисов, которым нужно взаимодействовать
- Вы хотите обнаруживать критические изменения до развертывания
- Вы хотите развивать свои API с уверенностью
- Вы хотите снизить потребность в сквозном тестировании

## Преимущества контрактов, управляемых потребителем

1. **Четкое разделение обязанностей**:
   - Обязанности поставщика и потребителя четко определены
   - API-контракты явные и версионированные

2. **Эволюционный дизайн**:
   - Изменения в контрактах обнаруживаются рано
   - Критические изменения идентифицируются до развертывания

3. **Уверенность в развертываниях**:
   - Проверенные контракты обеспечивают совместимость
   - Снижен риск проблем интеграции

4. **Документация как побочный продукт**:
   - Контракты служат живой документацией
   - Интеграция OpenAPI предоставляет дополнительную документацию API

## Ресурсы

Можно так же посмотреть [статью по внедрению контрактного тестирования](Внедрение%20контрактного%20тестирования%20с%20Pact%20в%20приложениях%20Java%20Spring.md)

### Документация и руководства

- [Официальная документация Pact](https://docs.pact.io/)
- [Документация Pact JVM](https://github.com/pact-foundation/pact-jvm)
- [Руководство по интеграции Spring Boot и Pact](https://docs.pact.io/implementation_guides/jvm/provider/spring)

### Инструменты и плагины

- [Pact Broker](https://github.com/pact-foundation/pact_broker)
- [Pact JVM Provider Spring](https://github.com/pact-foundation/pact-jvm/tree/master/provider/spring)
- [Pact JVM Consumer JUnit 5](https://github.com/pact-foundation/pact-jvm/tree/master/consumer/junit5)

### Дополнительное чтение

- [Контракты, управляемые потребителем: шаблон эволюции сервисов](https://martinfowler.com/articles/consumerDrivenContracts.html)
- [Стратегии тестирования микросервисов](https://martinfowler.com/articles/microservice-testing/)
